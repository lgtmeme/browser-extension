// @flow
// @format

function stripHeadersForNewRequest(oldHeaders: Headers): Headers {
  const REMOVE_HEADERS = [
    // We don't want to include content-type for a new request, because when
    // a new FormData is added, a new content-type mixed boundary value is auto
    // generated by the browser. Copying the old content-type uses the old
    // boundary, but the form data embedded in the request would have a new
    // boundary, causing a `422 Unprocessable Entity` response.
    'content-type',
    // Ajax should always add this anyway
    'x-requested-with',
  ];
  const newHeaders = new window.Headers();
  Array.from(oldHeaders.entries()).forEach(entry => {
    const [key, value] = entry;
    if (!REMOVE_HEADERS.includes(key.toLowerCase())) {
      newHeaders.append(key, value);
    }
  });
  return newHeaders;
}

export async function cloneRequestWithNewFormData(
  oldRequest: Request,
  transform: (oldFormData: FormData) => ?FormData,
): Promise<Request> {
  // Must clone it so that the data field doesn't get touched. Once it's
  // touched, the request cannot be used in fetch.
  const oldFormData = await new Request(oldRequest.clone()).formData();
  const newFormData = transform(oldFormData) || oldFormData;
  return new Request(oldRequest.url, {
    body: newFormData,
    cache: oldRequest.cache,
    credentials: oldRequest.credentials,
    headers: stripHeadersForNewRequest(oldRequest.headers),
    integrity: oldRequest.integrity,
    method: oldRequest.method,
    mode: oldRequest.mode,
    redirect: oldRequest.redirect,
    referrer: oldRequest.referrer,
  });
}

export function cloneFormDataWithNewValue(
  oldFormData: FormData,
  transform: (key: string, value: string) => ?string,
): FormData {
  const newFormData = new window.FormData();
  Array.from(oldFormData.entries()).forEach(entry => {
    const key = entry[0];
    let value = entry[1];
    if (typeof value === 'string') {
      const newValue = transform(key, value);
      if (newValue != null) {
        value = newValue;
      }
    }
    newFormData.append(key, value);
  });
  return newFormData;
}
